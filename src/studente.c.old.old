#include "header.h"


struct studente_t{
    int matricola;
    int voto_AdE;
    int nof_elems;
    char glab; //gruppo laboratorio
};

//int sem_init; // identificatore del vettore di semafori
//int shr_mem; //identificatore della memoria condivisa
//int msg_id; //identificatore della coda di messaggi
//int volatile flagSignal=0;
//struct shared_data *project_data; //puntatore a memoria condivisa 

//void sigHandler (int sign);

int main (int argc, char **argcv) {
    struct studente_t studente;
    int pidi;
    struct sembuf presenza; //struttura dati di sistema per i semafori 
    struct sembuf w_dati;
    int shr_pos; //posizione propria nel vettore di memoria condivisa
    struct sigaction ends; // strutture dati di sistema per la gestione dei segnali
    sigset_t smask;
    //08_04_2019
    struct msginvite invito;
    struct msginvite received;
    struct msginvite answer;
    struct msgFromMaster VFinal;
    int count_rjt=0; //contatore numero rifiuti
    received.mtype=studente.matricola;
    int j=0;
    int count_elem=1;
    int count_inv=0;

    int nof_invites;
    
    pidi=0;
    //pid = getpid();
     printf("stampa pid %d",pidi);
    if(argcv != NULL) {
        studente.nof_elems = atoi(argcv[1]);
    }

    //TODO per ora la metto uguale, ma e' da cambiare perche' fa schifo
    studente.matricola = pidi;
    
    // inizializzo prendendo come seme il pid
    srand(pidi); 
    
    // il voto lo prendo come uniforme tra 18 e 30
    studente.voto_AdE = 18 + rand() % (30 -18 +1);


    //stabilisco il gruppo dello studente in base alla matricola
    if(studente.matricola%2 == 0) {
        studente.glab = '4';
    }
    else {
        studente.glab = '3';
    }
    
   
    //printf("Matricola %d, voto %d, pref. gruppo %d, lab. %c\n", studente.matricola, studente.voto_AdE, studente.nof_elems, studente.glab);


    //recupero semaforo
    if ((sem_init=semget(SEM_ID, 3, 0600))==-1){
        printf("Errore nel recupero del vettore di semafori \n ");
        exit(-2);
        }

    //recupero memoria condivisa
    if((shr_mem=shmget(SHR_ID, sizeof(*project_data), 0600))<0 ){
        printf("Errore nel recupero della memoria condivisa \n ");
        exit(-2);
        }
    project_data=shmat(shr_mem, NULL, 0);

    //LOCK SHARED MEMORY
    w_dati.sem_flg=0;
    w_dati.sem_num=SHR_SCRIPT;
    w_dati.sem_op=-1;
    semop(sem_init, &w_dati, 1);

    shr_pos=project_data->cur_idx;
    project_data->vec[shr_pos].matricola=studente.matricola;
    project_data->vec[shr_pos].voto_AdE=studente.voto_AdE;
    project_data->vec[shr_pos].glab=studente.glab;
    project_data->vec[shr_pos].stato_s='NA';
    project_data->vec[shr_pos].stato_g=' ';
    project_data->vec[shr_pos].nome_gruppo=0; // inizializzato a 0 per tutti 
    project_data->vec[shr_pos].tipo_componente=' ';
    project_data->vec[shr_pos].nof_elems=studente.nof_elems;
    //
    printf("prova s2");
    presenza.sem_num=INIT_READY;
    presenza.sem_op=1;
    semop(sem_init, &presenza, 1);
    project_data->cur_idx++;
    //UNLOCK
    w_dati.sem_flg=0;
    w_dati.sem_num=SHR_SCRIPT;
    w_dati.sem_op=-1;
    semop(sem_init, &w_dati, 1);
    
    printf("prova s3");
    ends.sa_handler=sigHandler;
    ends.sa_flags=0;
    sigemptyset(&smask);
    ends.sa_mask=smask;
    sigaction (SIGALRM, &ends, NULL);
    // gestione della coda di msg

    while (flagSignal==0){
        if (18<=studente.voto_AdE<=21){
            while (project_data->vec[shr_pos].stato_s=='NA'){
                if(msgreceive(msg_id, &received, sizeof(received)-sizeof(long), studente.matricola, 0)==-1){
                    if(errno==EINTR){ // interruzione da segnale
                        //fine del SIM_TIME
                        break;
                    }
                    printf("Errore nella ricezione del processo studente %d\n", getpid());
                }
                else{
                    if (received.aim=='I'){
                        //aggiorna i dati sulla propria condizione in shrmry
                        project_data->vec[shr_pos].stato_s='A';
                        project_data->vec[shr_pos].nome_gruppo=received.mitt; // inizializzato a 0 per tutti 
                        project_data->vec[shr_pos].tipo_componente='F';
                        //invia msg di accettazione

                        answer.mtype=received.mitt;
                        answer.mitt=studente.matricola;
                        answer.aim='A';

                        if(msgsend(msg_id, &answer, sizeof(answer)-sizeof(long),0)==-1){
                            if(flagSignal==1 && errno==EINTR){ // interruzione da segnale
                            //fine del SIM_TIME
                            break;
                            }
                            printf("Errore nell'invio della risposta del processo studente %d\n", getpid());
                        }
                        
                    }
                }
            }

        }
        if (22<=studente.voto_AdE<=27){
            //comportamento temporaneo

            //project_data->vec[shr_pos].stato='A';
            //project_data->vec[shr_pos].stato_g='C';
            //project_data->vec[shr_pos].stato_s='L';
            //project_data->ver[shr_pos].nome_gruppo=studente.matricola;
            while (exitStrategy== 0 && flagSignal==0 /*&& project_data->vec[shr_pos].stato_s=='F'*/){
                    //gli studenti con voti medi si mettono prima in ricezione inviti
                    printf("[Studente %d] (22-27) mi metto in ricezione \n", studente.matricola);

                    if(msgrcv(msg_id, &received, sizeof(received)-sizeof(long), studente.matricola, NOWAIT)==-1){
                        if(errno==EINTR){ // interruzione da segnale
                            //fine del SIM_TIME
                            printf("[Studente %d] Errore nella ricezione dei messaggi \n", studente.matricola);
                            exitStrategy =1;
                            break;
                        }
                        else{
                            if (project_data->vec[shr_pos].stato_s=='F' && received.aim=='I' && received.voto_AdE>=studente.voto_AdE && received.numCGr==studente.nof_elems && count_rjt<MAX_REJECT){
                                printf("[Studente %d] (22-27) ricevuto invito da %ld\n", studente.matricola, received.mitt);
                                //aggiorna i dati sulla propria condizione in shrmry
                                project_data->vec[shr_pos].stato_s='A';
                                project_data->vec[shr_pos].nome_gruppo=received.mitt; // inizializzato a 0 per tutti 
                                project_data->vec[shr_pos].tipo_componente='F';
                                //invia msg di accettazione ed esce

                                answer.mtype=received.mitt;
                                answer.mitt=studente.matricola;
                                answer.aim='A';

                                if(msgsnd(msg_id, &answer, sizeof(answer)-sizeof(long),0)==-1){
                                    if(flagSignal==1 && errno==EINTR){ // interruzione da segnale
                                        //fine del SIM_TIME
                                        exitStrategy =1;
                                        break;
                                    }
                                    printf("[Studente %d] Errore nell'invio della risposta\n", studente.matricola);
                                }
                            }
                            if(received.aim=='I' && count_rjt<MAX_REJECT && (received.voto_AdE<=studente.voto_AdE || received.numCGr!=studente.nof_elems)){
                                //invia msg di rifiuto e incrementa count_rjt
                                count_rjt++;


                                answer.mtype=received.mitt;
                                answer.mitt=studente.matricola;
                                answer.aim='R';

                                if(msgsnd(msg_id, &answer, sizeof(answer)-sizeof(long),0)==-1){
                                    if(flagSignal==1 && errno==EINTR){ // interruzione da segnale
                                        //fine del SIM_TIME
                                        exitStrategy =1;
                                        break;
                                    }
                                    printf("[Studente %d] Errore nell'invio della risposta\n", studente.matricola);
                                }
                                
                            }
                            //raggiunto massimo numero di rifiuti ed accettazione forzata
                            if(received.aim=='I' && count_rjt==MAX_REJECT)

                        }
                        
                    }


        }
        if (28<=studente.voto_AdE<=30){
                if(msgreceive(msg_id, &received, sizeof(received)-sizeof(long), studente.matricola, 0)==-1){
                    if(errno==EINTR){ // interruzione da segnale
                        //fine del SIM_TIME
                        break;
                        printf("Errore nella ricezione del processo studente %d\n", getpid());
                    }
                }
                    else if (errno==ENOMSG){ //la coda di msg Ã¨ vuota
                        j=0;
                        //decido di propormi come leader
                        project_data->vec[shr_pos].nome_gruppo=studente.matricola;
                        project_data->vec[shr_pos].tipo_componente='L';
                        project_data->vec[ahr.pos].stato_s='A';

                        for (j=0; j<POP_SIZE && count_elem<=nof_elems &&
                        count_inv<=nof_invites; j++){
                            if(project_data->vec[j].voto_AdE<=21 && project_data->vec[j].stato_s=='NA' 
                               && project_data->vec[j].glab==studente.glab && 
                               project_data->vec[j].nof_elems==studente.nof_elems){

                                   invito.mtype=project_data->vec[j].matricola;
                                   invito.aim='I';
                                   invito.mitt=studente.matricola;
                                   invito.voto_AdE=studente.voto_AdE;
                                   invito.numCGr=studente.nof_elems;

                                   if(msgsnd (msg_id, &invito, sizeof(invito)-sizeof(long),0)==-1){
                                        printf("Errore nella ricezione del processo studente %d\n", getpid());
                                        break;     
                                   }
                                   else{
                                   count_inv++;
                                   }
                            }
                            if(msgreceive(msg_id, &received, sizeof(invito)-sizeof(long), studente.matricola, 0)==-1){
                               printf("Errore nella ricezione del processo studente %d\n", getpid());
                                break;     
                            }
                            else if(received.aim=='A'){
                                count_elem++; 
                            }
                        } 
                        project_data->vec[shr_pos].stato_g='C';
                    
                    
                }      
        }  
    }
     printf("prova s4");
    exit(0);

}

void sigHandler (int sign){
    if(sign==SIGALRM){
        flagSignal=1;
    }
}

