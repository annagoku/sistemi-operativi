#include "header.h"


struct studente_t{
    int matricola;
    int voto_AdE;
    int nof_elems;
    char glab; //gruppo laboratorio
};

int sem_init; // identificatore del vettore di semafori
int shr_mem; //identificatore della memoria condivisa
int msg_id; //identificatore della coda di messaggi
int volatile flagSignal=0;
struct shared_data *project_data; //puntatore a memoria condivisa 

void sigHandler (int sign);

int main (int argc, char **argcv) {
    struct studente_t studente;
    pid_t pid;
    struct sembuf presenza; //struttura dati di sistema per i semafori 
    struct sembuf w_dati;
    int shr_pos; //posizione propria nel vettore di memoria condivisa
    struct sigaction ends; // strutture dati di sistema per la gestione dei segnali
    sigset_t smask;
     
     printf("studenteeeeeee  ");

    pid = getpid();
     printf("stampa pid %d",pid);
    if(argcv != NULL) {
        studente.nof_elems = atoi(argcv[1]);
    }

    //TODO per ora la metto uguale, ma e' da cambiare perche' fa schifo
    studente.matricola = pid;
    
    // inizializzo prendendo come seme il pid
    srand(pid); 
    
    // il voto lo prendo come uniforme tra 18 e 30
    studente.voto_AdE = 18 + rand() % (30 -18 +1);


    //stabilisco il gruppo dello studente in base alla matricola
    if(studente.matricola%2 == 0) {
        studente.glab = '4';
    }
    else {
        studente.glab = '3';
    }
    
   
    //printf("Matricola %d, voto %d, pref. gruppo %d, lab. %c\n", studente.matricola, studente.voto_AdE, studente.nof_elems, studente.glab);


    //recupero semaforo
    if ((sem_init=semget(SEM_ID, 3, 0600))==-1){
        printf("Errore nel recupero del vettore di semafori \n ");
        exit(-2);
        }

    //recupero memoria condivisa
    if((shr_mem=shmget(SHR_ID, sizeof(*project_data), 0600))<0 ){
        printf("Errore nel recupero della memoria condivisa \n ");
        exit(-2);
        }
    project_data=shmat(shr_mem, NULL, 0);

    //LOCK SHARED MEMORY
    w_dati.sem_flg=0;
    w_dati.sem_num=SHR_SCRIPT;
    w_dati.sem_op=-1;
    semop(sem_init, &w_dati, 1);

    shr_pos=project_data->cur_idx;
    project_data->vec[shr_pos].matricola=studente.matricola;
    project_data->vec[shr_pos].voto_AdE=studente.voto_AdE;
    project_data->vec[shr_pos].glab=studente.glab;
    project_data->vec[shr_pos].stato=' ';
    project_data->vec[shr_pos].numero_gruppo=0; // inizializzato a 0 per tutti 
    project_data->vec[shr_pos].tipo_componente=' ';
    //
    printf("prova s2");
    presenza.sem_num=INIT_READY;
    presenza.sem_op=1;
    semop(sem_init, &presenza, 1);
    project_data->cur_idx++;
    //UNLOCK
    w_dati.sem_flg=0;
    w_dati.sem_num=SHR_SCRIPT;
    w_dati.sem_op=-1;
    semop(sem_init, &w_dati, 1);
    
    printf("prova s3");
    while (flagSignal==0){
       
        ends.sa_handler=sigHandler;
        ends.sa_flags=0;
        sigemptyset(&smask);
        ends.sa_mask=smask;
        sigaction (SIGALRM, &ends, NULL);
        
         // gestione della coda di msg
    }
     printf("prova s4");
    exit(0);

}

void sigHandler (int sign){
    if(sign==SIGALRM){
        flagSignal=1;
    }
}

